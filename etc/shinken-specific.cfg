#This config file defines Shinken specific objects like
#satellites or Realms
#
#This file can be used for defining a simple environement :
#*one scheduler that schedules the checks (but doesn't launch them)
#*one poller (that launches the checks)
#*one reactionner (that sends the notifiations)
#*one broker (that gives jobs to modules. Modules export data like logs, status.dat, mysql export, etc etc)
#*some of the brokers modules (that do the jobs)
#*one arbiter (that reads the configuration and dispatches it to all others)

#So there is no high availability here, just a simple "Nagios equivalent" (but with
#more perf and less code! )

#The scheduler is a "Host manager". It gets the hosts and theirs
#services and it schedules the checks for the pollers.
define scheduler{
       scheduler_name	scheduler-1   ; just the name
       address	localhost             ; ip or dns address of the daemon
       port	7768                  ; tcp port of the daemon

       #optional
       spare	0                     ; (0 = not a spare, 1 = is spare)
       weight		1             ; (some schedulers can manage more hosts than others)
       timeout		3	      ; 'ping' timeout 
       data_timeout	120	      ; 'data send' timeout
       max_check_attempts	3     ;  if at least max_check_attempts ping failed, the node is DEAD
       check_interval		60    ; ping it every minute
#       modules			PickleRetention

# Interesting modules :
#   PickleRetention    :        Save data before exiting in flat file
#   MemcacheRetention  :        Same but in a memcache server
#   RedisRetention     :        same, but in a Redis server :)
#   NagiosRetention    :        only READ retention info from a nagios retention file

       #advanced feature
       realm	All                   ; optional (realm are multisites features)
       }


#Pollers launch checks
define poller{
       poller_name	poller-1
       address  	localhost
       port     	7771

       #optional
       manage_sub_realms 0	; optional and advanced: does it take jobs from schedulers of sub realms?
       min_workers	 0	; optional : starts with N processes workers. 0 means : "number of cpus"
       max_workers	 0	; optional : no more than N processes workers. 0 means : "number of cpus"
       processes_by_worker	256	   ; optional : each workers manage 256 checks
       polling_interval		1       ; optional : take jobs from schedulers each 1 second
       timeout		3	      ; 'ping' timeout 
       data_timeout	120	      ; 'data send' timeout
       check_interval		60    ; ping it every minute
       max_check_attempts	3     ;  if at least max_check_attempts ping failed, the node is DEAD

       
       # advanced features
       #modules		NrpeBooster
       #poller_tags	None
       realm		All
}



# Poller can have a nrpe module : commands tagged with
# nrpe_poller as module_type will be managed by this module.
# it will bypass the launch of check_nrpe, and will do the
# connection itself.
define module{
       module_name	NrpeBooster
       module_type	nrpe_poller
}


#Reactionner launch notifications
define reactionner{
       reactionner_name		reactionner-1
       address			localhost
       port			7769
       spare			0

       #optionnal
       manage_sub_realms 0	;optionnal : like for poller
       min_workers	 1	;optionnal : like for poller
       max_workers	 15	;optionnal : like for poller
       polling_interval		1       ;optionnal : like for poller

       timeout		3	      ; 'ping' timeout 
       data_timeout	120	      ; 'data send' timeout
       check_interval		60    ; ping it every minute
       max_check_attempts	3     ;  if at least max_check_attempts ping failed, the node is DEAD

       # Modules
       # modules		AndroidSMS

       #optionnal
       realm 			All
       }




#The broker manages data export (in flat file or in database)
#with it's modules
#Here just log files and status.dat file modules
define broker{
       broker_name	broker-1
       address		localhost
       port		7772
       spare		0

       # Which modules to load? LiveSatus and logs by default.
       modules		 Livestatus, Simple-log, WebUI


#      Other interesting modules to add :
#      PickleRetentionBroker    :  save data when quitting
#      ToNdodb_Mysql            :  NDO database support
#      NPCDMOD			: Use the PNP addon
#      Graphite-Perfdata        : Use teh Graphite backend for perfdata
#      WebUI			: Shinken Web interface

       # Optionnal
       manage_sub_realms 1   ; optionnal, like for poller
       manage_arbiters	 1   ; optionnal : take data from Arbiter. There should be
       			     ;only one broker for the arbiter

       check_interval		60    ; ping it every minute
       timeout		3	      ; 'ping' timeout 
       data_timeout	120	      ; 'data send' timeout
       max_check_attempts	3     ;  if at least max_check_attempts ping failed, the node is DEAD

       # Advanced
       realm 	All
       }


##Now the modules for the broker. The first 2 that are used, and all the others :)

#The log managment for ALL daemons (all in one log, cool isn't it? ).
define module{
       module_name      Simple-log
       module_type      simple_log
       path		nagios.log
       archive_path	archives/
}


#Status.dat and objects.cache export. For the old Nagios
#interface
define module{
       module_name		Status-Dat
       module_type		status_dat
       status_file		status.dat
       object_cache_file	objects.cache
       status_update_interval   15 ; update status.dat every 15s
}

#The log managment for ALL daemons (all in one log, cool isn't it? ).
define module{
       module_name      WebUI
       module_type      webui
       
       host		0.0.0.0       ; mean all interfaces
       port		7767

       # CHANGE THIS VALUE or someone can forge cookies !!!!!!!
       auth_secret	CHANGE_ME

       # Uncomment to present a text in the login form
       # login_text     	Welcome on Shinken WebUI.

       # Advanced options. Do not touch it if you don't
       # know what you are doing

       #http_backend    auto
       # ; can be also : wsgiref, cherrypy, paste, tornado, twisted
       # ; or gevent. automeans beast find in the system.

       modules		Apache_passwd,ActiveDir_UI,Cfg_password
       # Modules for the WebUI.
       # Apache_passwd : use an Apache htpasswd files for auth
       # ActiveDir_UI : use AD for auth and photo collect
       # Cfg_password : use passwords in contacts configuration for auth
       # PNP_UI : Use PNP graphs in the UI
       # GRAPHITE_UI : Use graphs from Graphite

}

#The log managment for ALL daemons (all in one log, cool isn't it? ).
define module{
       module_name      ActiveDir_UI
       module_type      ad_webui

#  UNCOMMENT this line to really enable this module and allow it to
#  connect!
#       ldap_uri         ldaps://myserver
       username		user
       password		password
       basedn		DC=google,DC=com

}


#The log managment for ALL daemons (all in one log, cool isn't it? ).
define module{
       module_name      Apache_passwd
       module_type      passwd_webui

       # WARNING : put the full PATH for this value!
       passwd 		/etc/shinken/htpasswd.users

}


#The log managment for ALL daemons (all in one log, cool isn't it? ).
define module{
       module_name      Cfg_password
       module_type      cfg_password_webui

}


##All other modules that can be called if you have installed
#the databases, or if you want to test something else :)

#Here the NDO/MySQL module
#So you can use with NagVis or Centreon
define module{
       module_name	ToNdodb_Mysql
       module_type	ndodb_mysql
       database		ndo       ; database name
       user		root      ; user of the database
       password		root      ; must be changed
       host		localhost ; host to connect to
       character_set	utf8      ;optionnal, UTF8 is the default

       # If you want to mix Shinken AND Nagios/icinga in the same db
       # you need to offset shinken instance id so they will not
       # override/delete other ones. Here for 5 nagios box.
       # nagios_mix_offset	  5 
}


#Here a NDO/Oracle module. For Icinga web connection
#Or for DBA that do not like MySQL
define module{
       module_name	ToNdodb_Oracle
       module_type	ndodb_oracle
       database		XE              ;database name (listener in fact)
       user		system          ;user to connect
       password		password        ;Yes I know I have to change my default password...
       oracle_home      /usr/lib/oracle/xe/app/oracle/product/10.2.0/server     ;optional, but can be useful
}


#Here for Merlin/MySQL. For the cool Ninja connection
define module{
       module_name      ToMerlindb_Mysql
       module_type      merlindb
       backend          mysql    ;backend to use, here mysql databse
       database         merlin   ;database name
       user             root     ; ? .. yes, the user of the database...
       password         root     ; wtf? you ask?
       host		localhost ; host of the database
       character_set    utf8     ;optionnal, UTF8 is the default
}


#Here the Merlin/Sqlite. No one uses it for now :)
#You look at something : it's also the merlindb module, like the previous,
#it's the same code, it's just the backend parameter that change (and path).
define module{
       module_name      ToMerlindb_Sqlite
       module_type      merlindb
       backend		sqlite 	  ;like the mysql, but sqlite :)
       database_path    /tmp/merlindb.sqlite  ;path of the sqlite file
}


#Here the couchdb export. Maybe use one day...
#I should do a mangodb too one day...
#and casandra...
#and voldemort...
#and all other NoSQL database in fact :)
define module{
       module_name      ToCouchdb
       module_type      couchdb
       user             root
       password         root
       host		localhost
}


#Export services perfdata to flat file. For centreon or
#perfparse
define module{
       module_name      Service-Perfdata
       module_type      service_perfdata
       path		service-perfdata
#      mode		a ; optionnal. a = append, w = overwrite, p =pipe
#      template		$LASTSERVICECHECK$\t$HOSTNAME$\t$SERVICEDESC$\t$SERVICEOUTPUT$\t$SERVICEPERFDATA$\t$SERVICESTATE$\n
}


#For hosts this time
#like the previous, but for hosts...
define module{
       module_name      Host-Perfdata
       module_type      host_perfdata
       path		host-perfdata
#      mode             a ; optionnal. a = append, w = overwrite, p =pipe
#      template         $LASTHOSTCHECK$\t$HOSTNAME$\t$HOSTOUTPUT$\t$HOSTSTATE$\t$HOSTPERFDATA$\n

}


# Graphite is a Graph backend
# http://graphite.wikidot.com/start
define module{
       module_name      Graphite-Perfdata
       module_type      graphite_perfdata
       host		localhost
       port 		2003
}


# Use PNP graphs in the WebUI
define module{
 module_name  GRAPHITE_UI
 module_type  graphite_webui
 uri 	      http://YOURSERVERNAME/   ; put the real PNP uri here. YOURSERVERNAME will be changed
                                          ; by the localname of the server
}

# You know livestatus? Yes, there a Livestatus module for shinken too :)
define module{
       module_name      Livestatus
       module_type      livestatus
       host		*	; * = listen on all configured ip addresses
       port		50000   ; port to listen
       database_file    livestatus.db

       # Only set debug if you got problem with this module
       # debug		/tmp/ls.debug
       # Set to 1 if you want to dump queries/responses too
       # warning : it's very verbose
       # debug_queries	0
}

#Send all logs to syslog
define module{
       module_name      Syslog
       module_type      syslog
}


#Use with the PNP interface
define module{
 module_name  NPCDMOD
 module_type  npcdmod
 config_file  /usr/local/pnp4nagios/etc/npcd.cfg
}

# Use PNP graphs in the WebUI
define module{
 module_name  PNP_UI
 module_type  pnp_webui
 uri 	      http://YOURSERVERNAME/pnp4nagios/   ; put the real PNP uri here. YOURSERVERNAME will be changed
                                              ; bu the localname of the server
}

# send into GLPI DB
# =============== Work with Plugin Monitoring of GLPI =============== 
define module{
  module_name  glpidb
  module_type  glpidb
  database		glpi       ; database name
  user		   root      ; user of the database
  password		root      ; must be changed
  host		   localhost ; host to connect to
}



############################# For the schedulers
#Now the good flat file for retention module
define module{
       module_name      PickleRetention
       module_type      pickle_retention_file_generic
       path             /tmp/retention.dat
}


#Now the good flat file for retention module
define module{
       module_name      PickleRetentionBroker
       module_type      pickle_retention_file_generic
       path             /tmp/retention_broker.dat
}

#Now the good flat file for retention module
define module{
       module_name      PickleRetentionArbiter
       module_type      pickle_retention_file_generic
       path             /tmp/retention_arbiter.dat
}


############################# For the schedulers
#Now the good flat file for retention module
define module{
       module_name      NagiosRetention
       module_type      nagios_retention_file
       path             /tmp/retention-nagios.dat
}


#Now the memcache one
#Now the good flat file for retention module
define module{
       module_name      MemcacheRetention
       module_type      memcache_retention
       server           127.0.0.1
       port             11211
}


#And the redis one
#Now the good flat file for retention module
define module{
       module_name      RedisRetention
       module_type      redis_retention
       server           127.0.0.1
}


# The old namaed pipe way from Nagios
define module{
       module_name      CommandFile
       module_type      named_pipe
       command_file     rw/nagios.cmd
}


#You know GLPI? You can load your hosts from this app (
#with the webservices plugins for GLPI, in xmlrpc mode)
#All hosts read from this will be added to the others of the
#standard flat file
#Warning : just load host_name, experimental.
define module{
       module_name      GLPIImport
       module_type      glpi_import
       uri 		http://localhost/glpi/plugins/webservices/xmlrpc.php
       login_name	glpi
       login_password	glpi
#       use_property       otherserial   ;optionnal. Will take use value from the otherserial
#			   field in GLPI (Inventory number:  in the web interface)
}

#You know GLPI? You can load all configuration from this app(
#with the webservices plugins for GLPI, in xmlrpc mode
#and with plugin monitoring for GLPI)
# =============== Work with Plugin Monitoring of GLPI =============== 
#All configuration read from this will be added to the others of the
#standard flat file
define module{
       module_name      GLPI
       module_type      glpi
       uri 		http://localhost/glpi/plugins/webservices/xmlrpc.php
       login_name	glpi
       login_password	glpi
}


#You know NSCA? You can send check results to shinken
#using send_nsca command
define module{
       module_name       NSCA
       module_type       nsca_server
       host              *
       port              5667
       encryption_method 0
       password          helloworld
}

#This module implement TSCA, a thrift interface to submit checks result
define module{
        module_name     TSCA
        module_type     tsca_server
        host            *
        port            9090
}

# You know VMWare? It's cool to VMotion VM, but after it's hard to
# follow host dependencies when it move. With this module, you can
# just lookup at the vcenter from times to times and update dependencies
define module{
       module_name	 VMWare_auto_linking
       module_type       hot_dependencies
       mapping_file      /tmp/vmware_mapping_file.json
       mapping_command   /usr/local/shinken/libexec/link_vmware_host_vm.py -x '/usr/local/shinken/libexec/check_esx3.pl' -V 'vcenter.mydomain.com' -u 'admin' -p 'secret' -r 'lower|nofqdn'  -o /tmp/vmware_mapping_file.json
       mapping_command_interval 60   ; optionnal
       mapping_command_timeout   300 ; optionnal
       
       # Only useful if you want debug output. Can
       # be verbose for large installations
       # debug 	    1
}

# Another way to update dependencies is to update a flat file
# See some examples to do that in the python script
define module{
      module_name      External_auto_linking
      module_type      hot_dependencies
      mapping_file     /tmp/external_mapping_file.json
      mapping_command  /usr/local/shinken/libexec/external_mapping.py -i /tmp/shinken_flat_mapping -o /tmp/external_mapping_file.json
      mapping_command_interval  60   ; optionnal
      mapping_command_timeout   300 ; optionnal
}

# Arbiter module to change on the fly a poller tag of a 
# command by another.
# Useful when you use a fixed configuration tool that do not allow you
# to configure poller_tag.
define module{
       module_name	HackCommandsPollerTag
       module_type      hack_commands_poller_tag
       cmd_line_match	(.*)check_esx3(.*)
       poller_tag	esx3
}


# Arbiter module to change on the fly a poller tag of hosts
# and services by search a custom macro
# Useful when you use a fixed configuration tool that do not allow you
# to configure poller_tag.
define module{
       module_name	   HackPollerTagByMacros
       module_type         hack_poller_tag_by_macros 
       host_macro_name     _poller_tag
       service_macro_name  _poller_tag
}


#Hosts and Services configuration can be pulled from a MySQL database
#All hosts and services read from the database will be added to the others of the
#standard flat file
#You can easily use an existing database, you just have to define the queries.
#It can be a useful module to use for HA too :)
#Warning : only for hosts and services
define module{
       module_name      MySQLImport
       module_type      mysql_import
       host		localhost
       login		root
       password		azerty
       database		supervision
       reqhosts 	SELECT host_name, alias, realm, address ,template AS 'use' FROM hosts
       reqservices	SELECT host_name, service_description, normal_check_interval, check_command ,template AS 'use' FROM services
       reqcontacts	SELECT contact_name, email, template AS 'use' FROM contacts
}

#The arbiter definition is optionnal
#WARNING : You must change host_name with the
#hostname of your machine !!!!
define arbiter{
       arbiter_name	Arbiter-Master
#       host_name	node1       ;result of the hostname command under Unix
       address		localhost   ;IP or DNS adress
       port		7770
       spare		0
#      uncomment the line below if you want to use the GLPI module and the NSCA one
#      modules		CommandFile,GLPIImport, NSCA, VMWare_auto_linking, TSCA

#      Uncomment theses lines in a HA architecture so the master
#      and slaves know how much time to wait the other
#       check_interval          60    ; ping it every minute
#       timeout         3             ; 'ping' timeout
#       data_timeout    120           ; 'data send' timeout
#       max_check_attempts      3     ;  if at least max_check_attempts ping failed, the node is DEAD



# List of interesting modules :
#  CommandFile              : open the named pipe nagios.cmd
#  PickleRetentionArbiter   : save data before exiting
#  NSCA                     : NSCA server
#  VMWare_auto_linking      : lookup at Vphere server for dependencies
#  GLPIImport               : import hosts from GLPI
#  TSCA                     : TSCA server
       }


# The receiver manages passive information. It's just a "buffer" that
# will be readfrom the arbiter to dispatch data
define receiver{
       receiver_name	receiver-1
       address		localhost
       port		7773
       spare		0

       # The main goal of the receiver is to load
       # Passive modules, like the NSCA one
       #modules		 NSCA,CommandFile

       timeout		3	      ; 'ping' timeout 
       data_timeout	120	      ; 'data send' timeout
       max_check_attempts	3     ;  if at least max_check_attempts ping failed, the node is DEAD
       check_interval		60    ; ping it every minute

       #advanced
       realm 	All
       }



#Very advanced feature for multisite managment.
#Consider to look at the doc before touching it :)
define realm{
       realm_name  All
       default		1
}





# Sample of an android SMS reactionner.
# You need 2 things important here:
# * modules AndroidSMS  : so you will load SMS sending code
# * reactionner_tags android_sms : so ONLY commands with this tag will
#   be send to this reactionner, no mail things.
#define reactionner{
#       reactionner_name		reactionner-Android
#       address			IPOFYOURANDROIDPHONE
#       port			7769
#       spare			0
#
#       timeout		3	      ; 'ping' timeout 
#       data_timeout	120	      ; 'data send' timeout
#       check_interval		60    ; ping it every minute
#       max_check_attempts	3     ;  if at least max_check_attempts ping failed, the node is DEAD
#
#       # Modules
#       modules		AndroidSMS
#
#	reactionner_tags	android_sms
#
#       #optionnal
#       realm 			All
#       }


# Reactionner can be launched under an android device
# and can be used to send SMS with this module
define module{
       module_name	AndroidSMS
       module_type	android_sms
}





